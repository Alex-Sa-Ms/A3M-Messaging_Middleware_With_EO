Flow control - which type? who implements?
Nodes, Sockets and Contexts?
	- Why would contexts be required?
Create generic socket?
	- interface?
	- functionalities?
Specialized sockets
	- Use the same public interface as the generic socket or allow custom interface?
		- The PAIR socket does not need the destination to be specified as it was already specified at creation time
Connection based?
	- What happens if the destination is not online?
		- Should a timeout be set and cancel the message?
Exon cancelling messages?
	- Only delete messages in queue and not ones that are tokens?

Falar de ao fechar um socket se houver uma tentativa de contacto mas que nunca foi respondida (caso de clientes).

Request-Reply faz roundrobin a enviar? E se tiver offline um does destinos?
	- Assumir que eventualmente fica online

Objetivo é permitir ser facil programar sem como no ZeroMQ em que é necessario pensar que as conexoes podem terminar e que as mensagens nas queues podem ser perdidas,
sendo necessario pensar em formas de as guardar para retransmitir caso seja necessário.

Criar janelas por socket para impedir que as mensagens enviadas por um nodo sejam monopolizadas por certos sockets.
	Possivel problema para resolver: Valores de omissao para o controlo de fluxo do Exon calculados para

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------

Problemas:
	- Exon identificar as mensagens (como garantir que sao unicos)
	- Exon notificar que as mensagens foram enviadas usando os ids gerados
		- Como fazer isto de forma eficiente, sem que as threads principais do algoritmo possam ficar bloqueadas
	- Controlo de fluxo do Exon adaptavel em funcao do RTT
	- Controlo de fluxo do A3M 
	- estatisticas e permitir administracao para eliminar conexoes/recursos inativos (noa importante para ja)
	- Pensar nas etiquetas logicas e pensar que pode ser possivel usar wildcards para receber de ou enviar para varias etiquetas.
	- Cache de associacoes do Exon é grow-only (para servidores é um grande problema já que um grande número de clientes os contacta.)
			- Solucao 1: Ser oblivious e ser removida quando os registos são removidos.
				- Overhead grande a cada vez que se pretender comunicar.
			- Solucao 2: Criar cache com tamanho limite do tipo LRU
				- Mais espaço utilizado
			- Solucao 3: Criar cache com tamanho limite com remoção aleatória

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------


1. Definir um valor P inicial. O N pode continuar a ser alterado usando o N_multiplier.
2. Ver como os RTTs sao utilizados para calcular o P. Usar essa formula para ir modificando o P, e o N por consequencia.
3. Alterar o P usando o AdjustableSemaphore é simples. É necessario ter cuidado que o valor nao pode ficar com uma janela mais pequena que 1 (um).
4. Alterar o N a qualquer momento é seguro? É que nao vale a pena alterar o P se o N nao variar.

(Estas janelas sao justas para nodos a distancias diferentes? Nodos mais perto devem ter um valor de P mais baixo do que nodos mais longe.)

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------

Lembrar solucao de controlo de fluxo do A3M discutida com o Professor, em que se definem janelas, no lado transmissor, para controlar/limitar o envio dos 
sockets. Permite definir tambem prioridades no trafego de certos sockets. Isto basicamente seria implementado utilizando um hash map que mapeia os ids das
mensagens (retornados pelo Exon ao enviar uma mensagem) aos identificadores dos sockets.

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------


Relativamente à questão 1, embora um inteiro ou até mesmo um long permitam o envio de uma grande quantidade de mensagens, o nº de mensagens que possibilita enviar é limitado, ou seja, seria necessário eventualmente regressar ao início. Já que este contador ficaria a funcionar de modo circular, para garantir que não existem colisões de IDs, apoio o uso de um contador atómico agregado a um timestamp. 

Na questão 2, o meu pensamento estava de facto falacioso, e não fazia qualquer sentido. Portanto, acho que de facto ter uma unbounded queue separada, para os recibos, deverá ser a solução.

Sobre a questão 3, eu cheguei a pensar numa solução em que na API se permitia indicar se existiria a vontade de receber recibos ou não. No entanto, a minha solução era global a todas as mensagens, i.e., ou se emitia um recibo para todas ou não se emitia nenhum recibo. Mas gosto da solução do Professor em que se menciona para cada mensagem se existe vontade em o recibo seja emitido ou não. A operação de "test and remove" ser bloqueante ou não bloqueante também parece ser possível. No entanto, para existir alguma complexidade para fazer a operação bloqueante funcionar de forma segura (sem deadlocks) e eficiente. 



Possivel solução segura (sem deadlocks) e eficiente para a operação "test and remove receipt" de forma bloqueante:
	
	1. Ao enviar uma mensagem deve ser mencionada a vontade de receber um recibo de receção.
	2. Existindo essa vontade, então é criado o recibo de receção, logo após a invocação do método send(),
		e colocado num HashSet de recibos não recibos. 
			- O propósito disto é para quando se fizer um pedido bloqueante não se bloquear uma thread para uma mensagem
				que já foi recebida ou que nunca será recebida.
	3. Aquando da receção de um ACK para uma mensagem cujo id se encontra no hashset, se existir pedido bloqueante para o
		id, então atualiza-se o objeto associado ao pedido bloqueante e acordar-se os interessados. Caso não exista, coloca-se o recibo 
		numa queue de recibos emitidos para que sejam verificados de forma sequencial.
	4. Um pedido bloqueante para um id resulta na criação de um objeto com um lock, uma bool, um contador e uma condição para await e signal.
		- O contador indica o nr de interessados no recibo e deve ser atualizado (incrementado/decrementado) por cada um dos interessados quando registam o interesse no recibo e quando verificam que este já foi emitido. O objeto deve ser colocado num hashmap, preparado para operações concorrentes, associado ao id da mensagem. O primeiro interessado cria o objeto, e o interessado cujo decremento do contador (após o recibo ser emitido) resulta num contador com valor igual a 0, deve remover o objeto do hashmap. 