----------------------------------------------------------------------------------
| AQUI SÃO ESCRITOS PROBLEMAS ENCONTRADOS NA CONCEPÇÃO DO MIDDLEWARE,            |
| E QUAL A SOLUÇÃO ENCONTRADA PARA TAIS PROBLEMAS                                |
| (PARA ESCRITA POSTERIO NA TESE).                                               |
| PROBLEMAS CUJA SOLUÇÃO NÃO FOI ENCONTRADA TAMBÉM DEVEM SER DOCUMENTADOS        |
| PARA TRABALHO FUTURO (VERIFICAR O FICHEIRO "Sketch Problemas e Solucoes A3M"). |
----------------------------------------------------------------------------------

******* Identificadores lógicos no Exon *******  

---- Problema ----

De momento, os registos (SendRecords e ReceiveRecords) são associados a um NodeId (Endereço IP + Porta):
	Map<NodeId,SendRecord> sr;
	Map<NodeId,ReceiveRecord> rr. 

A ideia é separar a identificação lógica dos nodos dos endereços de transporte, permitindo a recuperação do estado
associado a um nodo em casos de mobilidade, para além de permitir o envio através de identificadores lógicos, em vez
da especificação do endereço de transporte, i.e., o código seria
	
	```
	
	EOMiddleware eo = EOMiddleware.start(...);
	...
	byte[] msg = "Hello World!".getBytes();
	eo.send("nodeA",msg);

	```

	em vez de

	```
	
	EOMiddleware eo = EOMiddleware.start(...);
	...
	byte[] msg = "Hello World!".getBytes();
	NodeId nid = new NodeId("192.168.1.66", 12345);
	eo.send(nid, msg);

	```.

O objetivo desta modificação não é que o Exon encontre o endereço de transporte,
mas que permita a upper layer criar/modificar associações entre endereços de transporte
e identificadores lógicos. A forma como estas associações são descobertas não interessam ao Exon.
Esta alteração também deve continuar a permitir que as mensagens sejam enviadas através de endereços
de transporte.


---- Resolução ----

1. Criação de uma estrutura que relacione os endereços de transporte com os identificadores lógicos (chamada "atoid" de "address to identifier")
2. Associação dos identificadores lógicos (em vez dos endereços do transporte) com os registos (SendRecords e ReceiveRecords)
3. Ao criar os eventos de envio e rececao seria associado o identificador lógico e não o endereço de transporte, já que este poderá mudar entretanto.	
4. API:
	- send(nodeId : NodeId, msg : byte[]) -> mantém-se igual
	- send(ta : TransportAddress, msg : byte[]) -> 
		Verifica se já existe uma associacao entre o endereço e um identificador. 
		Se já existir, invoca send(nodeId, msg) com o identificador encontrado. 
		Se não existir, utiliza o endereço como identificador ou cria um identificador aleatório.
	- register(nodeId : NodeId, ta : TransportAddress) -> 
		Regista uma associação entre um endereço de transporte e um identificador lógico.
		Um identificador e um endereço de transporte estão fortemente associados. 
		Se o identificador já existir, o endereço associado a este é substituido.
		Se o endereço já existir, o identificador associado a este é substituido. Assim como os registos associados ao identificador anterior, têm o seu identificador substituido.
		E se existirem os dois em simultaneo? Assumindo um caso de mobilidade, o que se pretende é recuperar o estado que se encontra associado com outro endereço de transporte, portanto, o estado associado ao endereço de transporte "novo" deve ser eliminado, e depois realiza-se a substituição do endereço de transporte para o identificador.

		MOBILIDADE EXCLUSIVAMENTE COM O EXON NAO FUNCIONA... É PRECISO SER A UPPER LAYER SER INFORMADA DA MUDANÇA DE ENDEREÇO POR UM SERVIÇO EXTERNO E ATUALIZAR O ENDEREÇO OU NÃO IRÁ HAVER COMUNICAÇÃO. 
	

	- getNodeIdentifier(ta : TransportAddress) : NodeId
	- getTransportAddress(nid : NodeId) : TransportAddress
	- receive() -> 
		Verifica se já existe uma associacao entre o endereço e um identificador. 
		Se não existir, utiliza o endereço como identificador ou cria um identificador aleatório.
	- E se é feito um registo e em simultaneo recebe-se uma mensagem com o identificador anterior?
		- upper layer tem de ter isto em consideração. 
