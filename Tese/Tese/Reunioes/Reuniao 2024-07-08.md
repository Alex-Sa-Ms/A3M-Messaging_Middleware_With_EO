# Conclusões
## Flag "throwIfNone"
- A flag `throwIfNone` quando definida num método, tem como objetivo a emissão de uma exceção na ausência de links estabelecidos e por estabelecer. Isto permite que peças (dinâmicas) da topologia, responsáveis por iniciar processos de estabelecimento de links e que nunca receberão tais pedidos, não fiquem eternamente bloqueadas. 
- Como os sockets são thread-safe, a situação de falta de links, poderia ser resolvida por uma outra thread, no entanto, por conveniência e para facilitar a programação, pensou-se no uso desta flag. 
- Este comportamento é invocado por uma flag já que uma peça fixa da topologia, como um servidor, aguarda que outras peças iniciem o processo de estabelecimento de link, sendo então desejável que este tipo de peças possa ficar bloqueada até que um link seja estabelecido e que não seja emitida uma exceção na ausência de links.
- A flag é primariamente empregada pelos métodos genéricos `waitForLink()` e `waitForAvailableLink()` que esperam pelo estabelecimento de um link ou pela disponibilidade para envio de um link estabelecido, respetivamente.
 - Esta flag pode ser utilizada também em métodos de envio e receção.
	 - O `AbstractSocket` pode ter uma implementação base dos métodos de envio e receção com o argumento `throwIfNone`. Estas implementações devem emitir a exceção `UnsupportedOperationException`. Se for decidido que se pretende implementar esse método, então faz-se o @Override e expõe-se esses métodos na classe *wrapper* do Socket.
## Link retries
### Solução 1
- Permitir criar sockets antes de iniciar a instância. Ao invocar `start()`, a instância passa a processar mensagens recebidas que incluem pedidos de ligação. Deste modo, evita-se rejeitar pedidos de ligação porque a criação do socket está atrasada.
	```
		// create middleware instance
		A3MMiddleware middleware = A3MMiddleware.new("node1","192.168.1.99", 12345); 
		// create socket
		RepSocket server = RepSocket.create("server", middleware);
		// starts middleware
		middleware.start();
	```
- O problema desta solução é não cobrir sockets que são criados após a instância ser iniciada.
### Solução 2 (final)
- Inclui a proposta da solução 1.
- Contempla retries de pedidos de ligação.
- O ZeroMQ não parece ter limites de pedidos de ligação, mas não custa incluir como uma opção base que tem como valor default "infinito". Possui, no entanto, um mínimo e máximo para o timeout entre cada pedido. A cada falha no pedido, o valor do timeout aumenta exponencialmente até ao valor máximo se este tiver sido definido. Se o valor máximo não tiver sido definido, o valor de timeout permanece igual.
	- Não deve ser necessário valores de timeouts aleatórios para proteger contra thundering herd, mas pode ser algo a mencionar na tese.
- As novas tentativas de ligação devem ser executadas pela única thread do middleware (a reader thread). Para isto é necessário que os sockets tenham um método privado, para não ser exposto às subclasses, que aquando da receção de uma resposta negativa a um pedido de ligação por ausência do socket destino, permite o socket criar um evento `LinkRetryEvent` e colocá-lo na queue de eventos a serem realizados pela reader thread.
	- Um evento do tipo `SendMsgEvent` que permitiria agendar o envio de uma mensagem parece uma solução válida e útil até para outras situações, no entanto, é importante que antes de reenviar o pedido de ligação se verifique que o socket não se encontra fechado e que o cliente não cancelou o processo de ligação com o destino em questão (através do método `unlink()`).
	- Para realizar estas verificações, a reader thread, no momento de execução do evento `LinkRetryEvent` apenas necessita de executar o método `linkRetry(sid : SocketIdentifier)` do socket que se encontra incluído no objeto do evento.
	- O método `linkRetry(sid : SocketIdentifier)` fará todas as verificações necessárias: (1) socket não se encontra fechado; (2) link em questão encontra-se num estado de aguardar retry.
	- Se o método tiver visibilidade "default" pode evitar-se que seja visto por classes que não devem, mas não deixa de ser poder ser exposto se uma subclasse do `AbstractSocket` for criada dentro do meu package.
## Expor eventos do socket
- A exposição de eventos do socket como "Link estabelecido com X", "Link recusado por X", "Sem links", etc.
- No caso de ser necessário e mesmo relevante a exposição destes eventos, estes podem ser expostos a partir de um método diferente do `receive()` de mensagens. Isto permite evitar que a programação do fluxo normal seja complicada desnecessariamente. 
- No fundo, isto poderia ser um *log* do socket.
- Neste momento, esta funcionalidade não aparenta ser necessária. ZeroMQ e NNG não possuem nada parecido com esta funcionalidade.

## Esperar por um link disponível para envio
- Método `waitForAvailableLink() : SocketIdentifier` que espera que um link esteja disponível para envio e retorna o identificador desse link.
- O principal objetivo deste método é auxiliar a programação interna dos sockets de alto-nível.
- Poderá eventualmente ser exposto por um socket de alto-nível que assim o entenda.
### Implementação base
- *Queue de pedidos* geral e por cada link.
- *Lock condition* geral e por cada link.
- Clock (inteiro) do socket que incrementa a cada pedido feito. Usar um timestamp não é indicado porque diferentes threads podem visualizar diferentes valores do relógio do dispositivo.
- Quando o pedido é relativo a um link específico, este apenas precisa de registar o clock do momento em que o pedido foi efetuado.
- Quando o pedido é geral, é necessário que a thread acordada seja informada do link que está disponível. Para isso, o pedido deve possibilitar que seja registado o identificador do link disponível.
- Quando um link transita do estado indisponível para disponível (edge-triggered) é feita a verificação de que thread é que deve ser acordada: deve-se acordar uma thread geral ou acordar uma thread que requisitou o link em específico. Para chegar a esta conclusão, deve comparar-se o relógio do primeiro pedido da queue geral com o relógio do primeiro pedido da queue do link que ficou disponível. Se o menor relógio pertencer à queue geral então deve acordar-se uma thread que aguarda por um link qualquer, caso contrário acorda-se uma thread que aguarda pelo link em específico.
- Uma thread que invoca `waitForAvailableLink() : SocketIdentifier` pretende aguardar que um link qualquer fique disponível.  A invocação deste método deve começar por verificar se existem pedidos gerais. Se existirem, então este deve adicionar um novo pedido à queue de pedidos gerais e invocar na condição geral o método `wait()` de forma a aguardar pela sua vez de enviar uma mensagem. Se não existirem pedidos, pode iterar sobre .
- <span style="color:red">Quando é que uma thread é acordada? Ser acordada apenas quando um link passa de indisponível para disponível parece não ser apropriado, e potencialmente leva a deadlocks se as threads não verificarem a capacidade de enviar mensagens antes de adormecerem.</span>
## Wait for link availability (to send)
Waiting for a link to become available for sending a message is crucial for developing blocking send methods for various socket types. This functionality might be offered, to the client, by a socket implementation depending on its semantics.

Two key functionalities are needed: waiting for a specific link to become available (`waitForLinkAvailability(sid: SocketIdentifier)`) and waiting for any link to become available (`waitForAvailableLink()`).

### Waiting for a Specific Link

Waiting for a specific link is a straightforward problem, commonly referred to as the Producer-Consumer problem. This can be easily solved using a single lock condition. When the link has credits, threads can return immediately. If the balance is insufficient, threads must wait using the lock condition. When credits are replenished, the lock condition is used to signal the appropriate number of threads that can be satisfied.

### Waiting for Any Link

The complexity increases when waiting for any link to become available. This introduces challenges related to fairness, thundering herd, and starvation.

1. **Fairness/Starvation**: The challenge is to evenly distribute link credits among waiting threads, regardless of whether they are link-specific[^1] or general threads[^2], and to prevent threads from never being signaled.

2. **Thundering Herd**: This problem is addressed by avoiding signaling multiple threads that cannot perform work, thereby preventing unnecessary context switches that degrade performance. Signaling a thread to await again when the return condition is unmet results in two unnecessary context switches.

[^1] Link-specific threads are threads interested in a single link.
[^2] General threads are threads interested in any link.

### Basic Implementation

A basic implementation might use a lock condition per link for link-specific waiting operations and a general lock condition for any link waiting operations. When a link's credits are replenished, the `signalAll()` method of both conditions could be invoked. Signaled threads would then check if the link balance is positive; if not, they would wait again. This approach, however, is not ideal due to potential races for credits, increased lock contention, pointless context switches, and possible starvation of slower threads.

### Fair(ish) implementation

<span style="color:red">Pode haver problema de starvation quando não é consumido o crédito? Se existir pode ser resolvido por se consumir o crédito e devolver o crédito caso se não se pretenda consumir. Esta é a solução mais segura, já que é mais fácil um desenvolvedor se esquecer de cancelar o credito pendente do que consumir o credito e devolver o credito caso verifique que já nao pretende consumi-lo.</span>

The chosen approach uses requests. There are two types of requests: link-specific and general. Each link has its own queue of link-specific requests, while general requests are kept in a common queue. Requests are given a ticket number to address fairness and starvation. When a link's credits are replenished, it signals waiting threads based on the ticket numbers of the requests. The link peeks at the first ticket number of both its own link-specific requests queue and the general requests queue. The queue with the smallest ticket number (or with requests) dictates which type of waiting thread should be signaled. This approach solves the fairness/starvation problem between different types of threads. To ensure fairness among threads of the same type, a fair version of the lock can be employed. The thundering herd problem is addressed by signaling only the number of threads that the link credits can satisfy.

A completely fair implementation would require threads to enter the waiting queues even if there are enough credits to satisfy all waiting threads. This would result in two unnecessary context switches: when the threads enter the queue and when they are signaled shortly after. To prevent new "waiting" threads from stealing credits from already waiting threads, requests have three states: new, unsettled, and settled. A request is new when created, becomes unsettled when a thread is signaled, and becomes settled (deleted) when the thread reacquires the lock and secures the credit. A new "waiting" thread can return immediately only if the link credits exceed the combined number of new and unsettled requests.






Estava nos 38:22 da gravacao.