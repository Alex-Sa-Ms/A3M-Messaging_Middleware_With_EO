# Conclusões
## Flag "throwIfNone"
- A flag `throwIfNone` quando definida num método, tem como objetivo a emissão de uma exceção na ausência de links estabelecidos e por estabelecer. Isto permite que peças (dinâmicas) da topologia, responsáveis por iniciar processos de estabelecimento de links e que nunca receberão tais pedidos, não fiquem eternamente bloqueadas. 
- Como os sockets são thread-safe, a situação de falta de links, poderia ser resolvida por uma outra thread, no entanto, por conveniência e para facilitar a programação, pensou-se no uso desta flag. 
- Este comportamento é invocado por uma flag já que uma peça fixa da topologia, como um servidor, aguarda que outras peças iniciem o processo de estabelecimento de link, sendo então desejável que este tipo de peças possa ficar bloqueada até que um link seja estabelecido e que não seja emitida uma exceção na ausência de links.
- A flag é primariamente empregada pelos métodos genéricos `waitForLink()` e `waitForAvailableLink()` que esperam pelo estabelecimento de um link ou pela disponibilidade para envio de um link estabelecido, respetivamente.
 - Esta flag pode ser utilizada também em métodos de envio e receção.
	 - O `AbstractSocket` pode ter uma implementação base dos métodos de envio e receção com o argumento `throwIfNone`. Estas implementações devem emitir a exceção `UnsupportedOperationException`. Se for decidido que se pretende implementar esse método, então faz-se o @Override e expõe-se esses métodos na classe *wrapper* do Socket.
## Link retries
### Solução 1
- Permitir criar sockets antes de iniciar a instância. Ao invocar `start()`, a instância passa a processar mensagens recebidas que incluem pedidos de ligação. Deste modo, evita-se rejeitar pedidos de ligação porque a criação do socket está atrasada.
	```
		// create middleware instance
		A3MMiddleware middleware = A3MMiddleware.new("node1","192.168.1.99", 12345); 
		// create socket
		RepSocket server = RepSocket.create("server", middleware);
		// starts middleware
		middleware.start();
	```
- O problema desta solução é não cobrir sockets que são criados após a instância ser iniciada.
### Solução 2 (final)
- Inclui a proposta da solução 1.
- Contempla retries de pedidos de ligação.
- O ZeroMQ não parece ter limites de pedidos de ligação, mas não custa incluir como uma opção base que tem como valor default "infinito". Possui, no entanto, um mínimo e máximo para o timeout entre cada pedido. A cada falha no pedido, o valor do timeout aumenta exponencialmente até ao valor máximo se este tiver sido definido. Se o valor máximo não tiver sido definido, o valor de timeout permanece igual.
	- Não deve ser necessário valores de timeouts aleatórios para proteger contra thundering herd, mas pode ser algo a mencionar na tese.
- As novas tentativas de ligação devem ser executadas pela única thread do middleware (a reader thread). Para isto é necessário que os sockets tenham um método privado, para não ser exposto às subclasses, que aquando da receção de uma resposta negativa a um pedido de ligação por ausência do socket destino, permite o socket criar um evento `LinkRetryEvent` e colocá-lo na queue de eventos a serem realizados pela reader thread.
	- Um evento do tipo `SendMsgEvent` que permitiria agendar o envio de uma mensagem parece uma solução válida e útil até para outras situações, no entanto, é importante que antes de reenviar o pedido de ligação se verifique que o socket não se encontra fechado e que o cliente não cancelou o processo de ligação com o destino em questão (através do método `unlink()`).
	- Para realizar estas verificações, a reader thread, no momento de execução do evento `LinkRetryEvent` apenas necessita de executar o método `linkRetry(sid : SocketIdentifier)` do socket que se encontra incluído no objeto do evento.
	- O método `linkRetry(sid : SocketIdentifier)` fará todas as verificações necessárias: (1) socket não se encontra fechado; (2) link em questão encontra-se num estado de aguardar retry.
	- Se o método tiver visibilidade "default" pode evitar-se que seja visto por classes que não devem, mas não deixa de ser poder ser exposto se uma subclasse do `AbstractSocket` for criada dentro do meu package.
## Expor eventos do socket
- A exposição de eventos do socket como "Link estabelecido com X", "Link recusado por X", "Sem links", etc.
- No caso de ser necessário e mesmo relevante a exposição destes eventos, estes podem ser expostos a partir de um método diferente do `receive()` de mensagens. Isto permite evitar que a programação do fluxo normal seja complicada desnecessariamente. 
- No fundo, isto poderia ser um *log* do socket.
- Neste momento, esta funcionalidade não aparenta ser necessária. ZeroMQ e NNG não possuem nada parecido com esta funcionalidade.

## Esperar por um link disponível para envio
- Método `waitForAvailableLink() : SocketIdentifier` que espera que um link esteja disponível para envio e retorna o identificador desse link.
- O principal objetivo deste método é auxiliar a programação interna dos sockets de alto-nível.
- Poderá eventualmente ser exposto por um socket de alto-nível que assim o entenda.
### Implementação base
- *Queue de pedidos* geral e por cada link.
- *Lock condition* geral e por cada link.
- Clock (inteiro) do socket que incrementa a cada pedido feito. Usar um timestamp não é indicado porque diferentes threads podem visualizar diferentes valores do relógio do dispositivo.
- Quando o pedido é relativo a um link específico, este apenas precisa de registar o clock do momento em que o pedido foi efetuado.
- Quando o pedido é geral, é necessário que a thread acordada seja informada do link que está disponível. Para isso, o pedido deve possibilitar que seja registado o identificador do link disponível.
- Quando um link transita do estado indisponível para disponível (edge-triggered) é feita a verificação de que thread é que deve ser acordada: deve-se acordar uma thread geral ou acordar uma thread que requisitou o link em específico. Para chegar a esta conclusão, deve comparar-se o relógio do primeiro pedido da queue geral com o relógio do primeiro pedido da queue do link que ficou disponível. Se o menor relógio pertencer à queue geral então deve acordar-se uma thread que aguarda por um link qualquer, caso contrário acorda-se uma thread que aguarda pelo link em específico.
- Uma thread que invoca `waitForAvailableLink() : SocketIdentifier` pretende aguardar que um link qualquer fique disponível.  A invocação deste método deve começar por verificar se existem pedidos gerais. Se existirem, então este deve adicionar um novo pedido à queue de pedidos gerais e invocar na condição geral o método `wait()` de forma a aguardar pela sua vez de enviar uma mensagem. Se não existirem pedidos, pode iterar sobre .
- <span style="color:red">Quando é que uma thread é acordada? Ser acordada apenas quando um link passa de indisponível para disponível parece não ser apropriado, e potencialmente leva a deadlocks se as threads não verificarem a capacidade de enviar mensagens antes de adormecerem.</span>
## Wait for link availability (to send)
Waiting for a link to become available for sending a message is crucial for developing blocking send methods for various socket types. The exposure of this functionality might even be useful to a client depending on the semantics of the socket[^a].

[^a] The process of safely exposing the functionality is elaborated further ahead. 

Two key functionalities are needed: waiting for a specific link to become available (`waitForLinkAvailability(sid: SocketIdentifier)`) and waiting for any link to become available (`waitForAvailableLink()`).

### Waiting for a Specific Link

Waiting for a specific link is a straightforward problem, commonly referred to as the Producer-Consumer problem. This can be easily solved using a single lock condition. When the link has credits, threads can return immediately. If the balance is insufficient, threads must wait using the lock condition. When credits are replenished, the lock condition is used to signal the appropriate number of threads that can be satisfied.

### Waiting for Any Link

The complexity increases when waiting for any link to become available. This introduces challenges related to fairness, thundering herd, and starvation.

1. **Fairness/Starvation**: The challenge is to evenly distribute link credits among waiting threads, regardless of whether they are link-specific[^1] or general threads[^2], and to prevent threads from never being signaled.

2. **Thundering Herd**: This problem is addressed by avoiding signaling multiple threads that cannot perform work, thereby preventing unnecessary context switches that degrade performance. Signaling a thread to await again when the return condition is unmet results in two unnecessary context switches.

[^1] Link-specific threads are threads interested in a single link.
[^2] General threads are threads interested in any link.

### Basic Implementation

A basic implementation might use a lock condition per link for link-specific waiting operations and a general lock condition for any link waiting operations. When a link's credits are replenished, the `signalAll()` method of both conditions could be invoked. Signaled threads would then check if the link balance is positive; if not, they would wait again. This approach, however, is not ideal due to potential races for credits, increased lock contention, pointless context switches, and possible starvation of slower threads.

### Fair(ish) implementation

The chosen approach uses requests. There are two types of requests: link-specific and general. Each link has its own queue of link-specific requests, while general requests are kept in a common queue. Requests are given a ticket number to address fairness and starvation. When a link's credits are replenished, it signals waiting threads based on the ticket numbers of the requests. The link peeks at the first ticket number of both its own link-specific requests queue and the general requests queue. The queue with the smallest ticket number (or with requests) dictates which type of waiting thread should be signaled. This approach solves the fairness/starvation problem between different types of threads. To ensure fairness among threads of the same type, a fair version of the lock can be employed. The thundering herd problem is addressed by signaling only the number of threads that the link credits can satisfy.

A completely fair implementation would require threads to enter the waiting queues even if there are enough credits to satisfy all waiting threads. This would result in two unnecessary context switches: when the threads enter the queue and when they are signaled shortly after. To prevent new "waiting" threads from stealing credits from already waiting threads, requests have three states: new, unsettled, and settled. A request is new when created, becomes unsettled when a thread is signaled, and becomes settled (deleted) when the thread reacquires the lock and secures the credit. A new "waiting" thread can return immediately only if the link credits exceed the combined number of new and unsettled requests.
<span style="color:red">
<p>Pode haver problema de starvation quando não é consumido o crédito? Se existir pode ser resolvido por se consumir o crédito e devolver o crédito caso se não se pretenda consumir. Esta é a solução mais segura, já que é mais fácil um desenvolvedor se esquecer de cancelar o credito pendente do que consumir o credito e devolver o credito caso verifique que já nao pretende consumi-lo
<p>Esperar e consumir usando métodos diferentes pode dar problemas. Por exemplo, se a thread que for acordada decidir consumir multiplos creditos (enviar multiplas mensagens de uma vez).
<p>O método wait permitir enviar enquanto existirem créditos que satisfaçam todos os clientes e efetivamente consumir o crédito parece ser a solução ideal. 
<p> E se for preciso mais do que um crédito? 
<p> Deixar consumir os créditos que pretenderem sem indicar uma ordem pode ser perigoso. Digamos que se recebe um crédito para um certo link, e se decide acordar uma thread geral. Esta thread geral pode decidir consumir créditos de outro link, deixando uma thread especifica que poderia ter sido acordada e consumido o crédito do link. 
</span>
### Best solution
1. Scheduler - com a função apenas de agendar. Créditos de um link são recebidos do manager, e a partir daí apenas recebe variações (ex.: +10, -1, etc)
2. Flow Control Manager - Gestao dos creditos (controlo de fluxo) à parte
3. Links sao criados no scheduler e no manager para otimizar consulta de informacao no scheduler.
4. Manager envia atualizacoes de creditos para o scheduler.
5. Quando se usa métodos `wait()` deve-se usar `trySendMsg()` para enviar a mensagem e 
dar bypass à espera.
6. `sendMsg()` = `wait()` + `trySendMsg()`
7. `notSent(sid : SocketIdentifier)` para informar que não foi enviada uma mensagem. (Um link é identificado pelo socket que se encontra no outro lado, daí se usar o identificador de socket)
8. Como reservar créditos para lógicas mais elaboradas? Essencialmente o scheduler pode servir como reservador de créditos, i.e., como este apenas aplica as variações aos créditos dos links, se um socket tiver sido sinalizado então este "adquire" o crédito no scheduler (o crédito real presente no manager e o crédito no scheduler começam iguais mas variam com métodos diferentes).  Se esperar por outro link agora, poderá adquirir um crédito desse link também. Se decidir que não quer enviar, então usa o método `notSend()` para devolver os créditos a cada link que esperou. Isto é possível porque o scheduler e o manager do controlo de fluxo têm valores de créditos independentes e portanto é possível usar o scheduler para organizar e reservar créditos e proteger contra farm de créditos e gastos de créditos sem existir o envio de mensagens.
9. O método `trySendMsg()` deve possuir uma flag que permite dar bypass ao scheduler, já que quando é usado um método `wait()` este consome o crédito no scheduler, e não se pretende consumir outro crédito novamente no scheduler, apenas se pretende consumir crédito no *manager de controlo de fluxo*. É importante existir a flag porque pode-se querer realizar uma operação de `trySendMsg()` tendo em conta o estado do scheduler. Em vez de se usar a flag pode-se também optar por um método com nome explicito e documentando apropriadamente a diferença entre os métodos.
10. É da responsabilidade do desenvolvedor de um socket usar de forma apropriada os métodos que trabalham com o scheduler. Por exemplo, se usar métodos `wait()` e não der bypass ao scheduler então resultará na inconsistência do estado do scheduler com o do manager. O mesmo acontece se der bypass ao scheduler tanto após esperar com o método `wait()` como em momentos em que não espera. Mais um exemplo acontece ao usar o método que dá bypass ao scheduler usando um identificador de link diferente do que usou para esperar no método `wait()`.





1. Scheduler - responsible for scheduling only.  Credits per link are received by the manager at the moment of the link creation. After that, only credit variations are received (e.g.: +14; -1; etc)
2. Flow Control Manager - Credit management (flow control) separately
3. Links are created in the scheduler and manager for security and to optimize query of information in the scheduler.
4. When using `wait()` methods, a variant of `trySendMsg()` must be used to send the message and
bypass scheduler.
5. `sendMsg()` = `wait()` + `trySendMsg(bypassScheduler=true)`
6. `notSent(sid : SocketIdentifier)` to report that a message was not sent to the scheduler. (A link is identified by the socket on the other side, hence the use of a socket identifier to determine which link didn't have a message sent)
7. How can I reserve credits for more elaborate logic? Essentially, the scheduler can provide such functionality. Since the scheduler only applies variations to link credits, if a socket has been signaled then it "acquires" the credit in the scheduler (the real credit balance of the link is present in the manager, therefore the credit balance in the scheduler may vary in different ways of the credit balance present at the manager). It is possible to even wait for another link now, "acquire" the credit for that link, at the scheduler, as well, and then send both messages simultaneously using the send method that bypasses the scheduler. At any moment, if we do not want to proceed with the send operation, the `notSend()` method can be used, for each link with a reserved credit, to undo the "acquisition/reservation" of the credit. This is possible because the scheduler and flow control manager have independent credit values ​​and therefore it is possible to use the scheduler to organize and reserve credits and protect against credit farming as well as protect against credit spending without the actual sending of messages.
8. The `trySendMsg()` method must have a flag that allows bypassing the scheduler, since when a `wait()` method is used, it consumes credit in the scheduler, and we do not want to consume another credit again in the scheduler nor do we want the scheduler to say that other threads are already in line to acquire a credit. We only want to consume credit in flow control manager. It is important that the flag exists because we may want to perform a `trySendMsg()` operation taking into account the state of the scheduler, i.e., we want the scheduler to reject our attempt because other threads are already waiting for the availability of a/the link. 
9. It is the responsibility of the socket developer to appropriately use the methods that work with the scheduler. For example, if you use `wait()` methods and do not bypass the scheduler then it will result in the state of the scheduler being inconsistency with that of the manager, since credits are being consumed twice on the scheduler. The same happens if you bypass the scheduler both after waiting with the `wait()` method and at times when you don't wait. The scheduler will have more credits that the actual credits present in the manager. One more example happens when using the method that bypasses the scheduler using a different link identifier than the one used to wait for availability in the `wait()` method.
### Safely exposing waiting methods

Both waiting methods consume a credit from the link that allowed the successful return of the method. Consuming the credit prevents starvation and logic errors. If a thread decides it does not want to deliver a message 

Consuming/reserving a credit in a waiting method means that the actual send method needs to bypass the consume credit part. How to do this? Do we want the socket to have this logic as well? I don't think we want that. A *fair flow control manager* would need such a system as well in order to not expose a consume method that bypasses the requests to send .  

To expose the functionality in a safe way, the developer must implement a cancellation system that allows a client to express the will to not send a message prevents the client from consuming and farming credits without actually performing any work. 



Estava nos 47:23 da gravacao.