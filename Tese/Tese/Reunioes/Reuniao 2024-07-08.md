# Conclusões
## Flag "throwIfNone"
- A flag `throwIfNone` quando definida num método, tem como objetivo a emissão de uma exceção na ausência de links estabelecidos e por estabelecer. Isto permite que peças (dinâmicas) da topologia, responsáveis por iniciar processos de estabelecimento de links e que nunca receberão tais pedidos, não fiquem eternamente bloqueadas. 
- Como os sockets são thread-safe, a situação de falta de links, poderia ser resolvida por uma outra thread, no entanto, por conveniência e para facilitar a programação, pensou-se no uso desta flag. 
- Este comportamento é invocado por uma flag já que uma peça fixa da topologia, como um servidor, aguarda que outras peças iniciem o processo de estabelecimento de link, sendo então desejável que este tipo de peças possa ficar bloqueada até que um link seja estabelecido e que não seja emitida uma exceção na ausência de links.
- A flag é primariamente empregada pelos métodos genéricos `waitForLink()` e `waitForAvailableLink()` que esperam pelo estabelecimento de um link ou pela disponibilidade para envio de um link estabelecido, respetivamente.
 - Esta flag pode ser utilizada também em métodos de envio e receção.
	 - O `AbstractSocket` pode ter uma implementação base dos métodos de envio e receção com o argumento `throwIfNone`. Estas implementações devem emitir a exceção `UnsupportedOperationException`. Se for decidido que se pretende implementar esse método, então faz-se o @Override e expõe-se esses métodos na classe *wrapper* do Socket.
## Link retries
### Solução 1
- Permitir criar sockets antes de iniciar a instância. Ao invocar `start()`, a instância passa a processar mensagens recebidas que incluem pedidos de ligação. Deste modo, evita-se rejeitar pedidos de ligação porque a criação do socket está atrasada.
	```
		// create middleware instance
		A3MMiddleware middleware = A3MMiddleware.new("node1","192.168.1.99", 12345); 
		// create socket
		RepSocket server = RepSocket.create("server", middleware);
		// starts middleware
		middleware.start();
	```
- O problema desta solução é não cobrir sockets que são criados após a instância ser iniciada.
### Solução 2 (final)
- Inclui a proposta da solução 1.
- Contempla retries de pedidos de ligação.
- O ZeroMQ não parece ter limites de pedidos de ligação, mas não custa incluir como uma opção base que tem como valor default "infinito". Possui, no entanto, um mínimo e máximo para o timeout entre cada pedido. A cada falha no pedido, o valor do timeout aumenta exponencialmente até ao valor máximo se este tiver sido definido. Se o valor máximo não tiver sido definido, o valor de timeout permanece igual.
	- Não deve ser necessário valores de timeouts aleatórios para proteger contra thundering herd, mas pode ser algo a mencionar na tese.
- As novas tentativas de ligação devem ser executadas pela única thread do middleware (a reader thread). Para isto é necessário que os sockets tenham um método privado, para não ser exposto às subclasses, que aquando da receção de uma resposta negativa a um pedido de ligação por ausência do socket destino, permite o socket criar um evento `LinkRetryEvent` e colocá-lo na queue de eventos a serem realizados pela reader thread.
	- Um evento do tipo `SendMsgEvent` que permitiria agendar o envio de uma mensagem parece uma solução válida e útil até para outras situações, no entanto, é importante que antes de reenviar o pedido de ligação se verifique que o socket não se encontra fechado e que o cliente não cancelou o processo de ligação com o destino em questão (através do método `unlink()`).
	- Para realizar estas verificações, a reader thread, no momento de execução do evento `LinkRetryEvent` apenas necessita de executar o método `linkRetry(sid : SocketIdentifier)` do socket que se encontra incluído no objeto do evento.
	- O método `linkRetry(sid : SocketIdentifier)` fará todas as verificações necessárias: (1) socket não se encontra fechado; (2) link em questão encontra-se num estado de aguardar retry.
	- Se o método tiver visibilidade "default" pode evitar-se que seja visto por classes que não devem, mas não deixa de ser poder ser exposto se uma subclasse do `AbstractSocket` for criada dentro do meu package.
## Expor eventos do socket
- A exposição de eventos do socket como "Link estabelecido com X", "Link recusado por X", "Sem links", etc.
- No caso de ser necessário e mesmo relevante a exposição destes eventos, estes podem ser expostos a partir de um método diferente do `receive()` de mensagens. Isto permite evitar que a programação do fluxo normal seja complicada desnecessariamente. 
- No fundo, isto poderia ser um *log* do socket.
- Neste momento, esta funcionalidade não aparenta ser necessária. ZeroMQ e NNG não possuem nada parecido com esta funcionalidade.

## Esperar por um link disponível para envio
- Método `waitForAvailableLink() : SocketIdentifier` que espera que um link esteja disponível para envio e retorna o identificador desse link.
- O principal objetivo deste método é auxiliar a programação interna dos sockets de alto-nível.
- Poderá eventualmente ser exposto por um socket de alto-nível que assim o entenda.
### Implementação base
- *Queue de pedidos* geral e por cada link.
- *Lock condition* geral e por cada link.
- Clock (inteiro) do socket que incrementa a cada pedido feito. Usar um timestamp não é indicado porque diferentes threads podem visualizar diferentes valores do relógio do dispositivo.
- Quando o pedido é relativo a um link específico, este apenas precisa de registar o clock do momento em que o pedido foi efetuado.
- Quando o pedido é geral, é necessário que a thread acordada seja informada do link que está disponível. Para isso, o pedido deve possibilitar que seja registado o identificador do link disponível.
- Quando um link transita do estado indisponível para disponível (edge-triggered) é feita a verificação de que thread é que deve ser acordada: deve-se acordar uma thread geral ou acordar uma thread que requisitou o link em específico. Para chegar a esta conclusão, deve comparar-se o relógio do primeiro pedido da queue geral com o relógio do primeiro pedido da queue do link que ficou disponível. Se o menor relógio pertencer à queue geral então deve acordar-se uma thread que aguarda por um link qualquer, caso contrário acorda-se uma thread que aguarda pelo link em específico.
- Uma thread que invoca `waitForAvailableLink() : SocketIdentifier` pretende aguardar que um link qualquer fique disponível.  A invocação deste método deve começar por verificar se existem pedidos gerais. Se existirem, então este deve adicionar um novo pedido à queue de pedidos gerais e invocar na condição geral o método `wait()` de forma a aguardar pela sua vez de enviar uma mensagem. Se não existirem pedidos, pode iterar sobre .
- <span style="color:red">Quando é que uma thread é acordada? Ser acordada apenas quando um link passa de indisponível para disponível parece não ser apropriado, e potencialmente leva a deadlocks se as threads não verificarem a capacidade de enviar mensagens antes de adormecerem.</span>
### Implementação justa (fair)
- Adicionando-se 

Estava nos 38:22 da gravacao.