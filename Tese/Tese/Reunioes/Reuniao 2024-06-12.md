# Conclusões
## Construir o mínimo e evitar complexidades
- O Professor diz que nos devemos focar em construir o mínimo, porque pensar nas várias complexidades resulta em nunca mais acabar o trabalho.
- Exemplo:
	- Permitir que o "return code" do estabelecimento de um link seja "temporariamente indisponível". Isto exige criar um mecanismo de retry.
- <b style="color:limegreen">Na minha opinião, acho que referir estas ideias é bom, já que enriquece o trabalho, mesmo que não venham a ser implementadas. Pode-se sempre pensar nas ideias e falar nisso como sendo algo a implementar, mas no fim expressar as ideias que não serão implementadas no protótipo.</b>
	- Definir um MVP (minimum viable project)?
## Estabelecimento de um link
- Protocolo de ligação é demasiado complexo tendo em conta que não conhecemos um caso concreto em que a "negociação" é assimétrica, i.e., que requer que ambos os sockets tomem a sua decisão.
- Como pensado anteriormente, num caso simétrico, apenas é necessário existir a troca de mensagens do tipo LINK (nem é necessário enviar a decisão) porque uma negociação simétrica exige que ambos os sockets cheguem sempre à mesma conclusão. Um socket que recebe uma mensagem LINK, mesmo que verifique que não é compatível, envia uma mensagem LINK (e não uma mensagem UNLINK), já que a mensagem LINK permite chegar a essa conclusão.
- **Solução:**
	- O socket de alto-nível deve definir uma flag (do socket core) que indica se o protocolo de ligação é assimétrico. Esta flag pode ser transportada como metadados nas mensagens LINK. Se a flag for 'false' então o protocolo de ligação é simétrico, necessitando apenas que os sockets troquem mensagens LINK (contendo os metadados) entre si para que o link seja estabelecido. Relembrando que o protocolo é simétrico, não é necessário enviar a decisão, já que ambos chegam sempre à mesma decisão a partir dos metadados do outro.
	- Manter o que já foi pensado, mas mencionar a solução acima para poder contemplar protocolos simétricos sem necessitar de cumprir overhead desnecessário que apenas os protocolos assimétricos requerem.
	- Mencionar também que como não foram encontrados exemplos concretos, o protótipo apenas suporta protocolos simétricos, já que atualmente apenas se verifica se o tipo de socket é compatível.

## Limite de links
- O Professor diz que não há necessidade de limitar o nº de links já que o controlo de fluxo deve permitir definir o nº de créditos de um link para 0. 
	- No entanto:
		- isso permite que um nº infinito de sockets estabeleçam um link o que é uma vulnerabilidade do sistema, possibilitando DoS attacks. 
		- significa que deve existir um sistema complexo por trás que faz as gestão dos links.
- **Vantagens de estabelecer um limite para o nº de links**:
	- Elimina uma vulnerabilidade;
	- Elimina a necessidade de um sistema complexo de gestão de links já que o socket pode ser configurado para atender unicamente o nº de mensagens que consegue.
		- Nº de mensagens = limite de sockets * janela de mensagens por socket
- **Como implementar isto num protocolo de ligação simétrico?**
	- Enviar informação de disponibilidade para um novo link nos metadados da mensagem LINK.
	- Processamento e realização dos pedidos de link são feitos de forma sequencial, logo não há risco de links adicionais (para além do limite) serem estabelecidos, se os links pendentes forem assumidos como estabelecidos. 

## Aborte de envio de mensagem
- O envio de uma mensagem deve retornar uma exceção quando não existirem destinos possíveis. É de realçar que destinos possíveis não é o mesmo que destino disponíveis. Por exemplo, cria-se um socket, invoca-se o método link() para estabelecer ligação com um outro socket, e envia-se uma mensagem. O método do link() é assíncrono, logo, o estabelecimento do link pode não ser bem sucedido. Estando a thread bloqueada à espera de enviar a mensagem se não existir um possível destino, a thread deve ser desbloqueada e informada através de uma exceção. 
	- Um destino disponível é aquele que permite o envio imediato da mensagem.
	- Um destino possível é um link estabelecido ou um link pendente (a aguardar ser estabelecido). 
		- Um link estabelecido é possível porque pode estar indisponível, não sendo possível enviar mensagens devido ao controlo de fluxo.
		- Um link pendente é possível porque se a ligação for estabelecida com sucesso, então este poderá vir a ficar disponível, possibilitando o envio da mensagem.

## Envio de mensagens antes de o link ser estabelecido
- A mensagem LINK deve transportar o nº de créditos ou tamanho da janela que o socket pretende disponibilizar ao socket com que se pretende formar o link. 
- Até que sejam recebidos créditos ou um tamanho de janela positivo (e que seja verificada a compatibilidade) um socket não consegue enviar mensagens, já que o socket destino ainda não estará marcado com *linked*.
- No entanto, consideremos o estabelecimento simétrico em que:
	1. Socket A envia mensagem LINK para socket B.
	2. Socket B recebe a mensagem LINK e verifica que é compatível com o socket A.
	3. Socket B envia mensagem LINK para socket A e marca o socket A como ligado.
	4. Socket A recebe a mensagem LINK e verifica que é compatível com o socket A.
	5. Socket A marca o socket B como ligado.
- Podemos verificar que existe sempre um socket (socket B no exemplo) que marca o link como estabelecido primeiro. Não existindo nodos bizantinos, é garantido que o outro socket eventualmente também o fará. No entanto, no intervalo entre estes dois acontecimentos é possível que o primeiro socket a fazer essa ação possa entregar mensagens ao outro socket antes da mensagem que resulta no estabelecimento do link chegar. Já que as mensagens recebidas pelo socket que ainda não estabeleceu o link podem requerer o envio de mensagens para o outro socket, e tal não pode acontecer até o link ser estabelecido, o ideal é o **socket core criar uma queue temporária e armazenar essas mensagens até que o link seja estabelecido**. Após o link ser marcado como estabelecido, é invocado o processamento de todas essas mensagens e finalmente requisitada a eliminação da queue já que não será mais necessária.
	- Criar queues de envio temporárias poderia ser uma solução, mas admitindo que os metadados dos sockets são importantes para a lógica do socket, faz mais sentido atrasar a entrega das mensagens até que a mensagem que estabelece o link e carrega os metadados chegue.
	- <b style="color:limegreen">Nota:</b> No caso do processo assimétrico de estabelecimento do link que requer 3 mensagens, é possível que a receção de mensagens de dados seja feita após já se ter recebido os metadados do outro socket. Nesse caso, pode-se assumir que a receção de uma mensagem que não seja relacionada com os links, como se tivesse sido recebido a confirmação do estabelecimento do link, e portanto pode-se entregar a mensagem ao socket de alto-nível. No caso do processo simétrico, apenas se trocam mensagens LINK logo, não possuindo os metadados do outro socket, pode resultar em problemas na lógica do socket de alto nível que pode requerer o tipo do socket para criar as mensagens, isto porque pode ser compatível com diversos tipos de sockets, e cada socket pode requerer diferentes tratamentos das mensagens.

## Controlo de fluxo no socket core
- Controlo de fluxo deve ser feito sobre mensagens com tipo "DATA" que correspondem a mensagens de utilizador.
- Socket core não consegue fazer o controlo de fluxo automaticamente.
- Os créditos de fluxo apenas devem ser retornados ao transmissor após a mensagem ser entregue à aplicação.
- Como não se consegue fazer a entrega automática das mensagens à aplicação, o *socket core* deve possuir um método que permite ao socket definir quando uma mensagem foi entregue.
- Também deve haver um método pra dizer quando é que se consome um crédito?
- <b style="color:red">Pensar melhor neste assunto. Mensagens do tipo DATA consomem automaticamente crédito mas continua a ser necessário que o socket confirme quando esta é entregue à aplicação?</b>

## Mensagens prioritárias
- Professor deu ideia de criar mensagens prioritárias, incluindo até modificar o Exon para permitir definir mensagens prioritárias.
- Mensagens prioritárias não no nível do middleware e sockets, mas também permitir que o utilizador possa aceder a este tipo de funcionalidade.
	- **Parece-me perigoso permitir o utilizador ter acesso a estas funcionalidades. Seria algo abusado com certeza.**
- O propósito principal das mensagens prioritárias é escapar a mecanismos que possam atrasar a mensagem, como controlo de fluxo, etc.

## Tipos de mensagens
- **Minha ideia inicial:** 
	- Ter um tipo de mensagens designado "mensagem de controlo". 
	- O socket de alto nível referiria o tipo de mensagem de controlo no payload.
	- Permitiria deixar o espaço de tipos de mensagem disponível para funcionalidades *core* do middleware.
	- Exige a consulta de diferentes tabelas para fazer debug, para além de todas as mensagens de controlo necessitarem de mais bytes para descrever o tipo da mensagem de controlo.
- **Solução Professor:**
	- Espaço do tipo de mensagens pode ser aproveita e ser preenchido com tipos de mensagens dos diferentes tipos de sockets.
	- Espaço do tipo de mensagens é comum aos diferentes sockets logo:
		- permite o reaproveitamento dos tipos de mensagens por parte de diferentes tipos de sockets referentes a diferentes padrões de comunicação.
		- facilita o debug já que apenas é necessário consultar uma tabela de tipos de mensagens.
	- Apesar de "padrões de comunicação não surgirem como nascem cogumelos" (PSA, 2024), o espaço do tipo de mensagens consegue ser facilmente esgotado, impedindo a introdução de novas funcionalidades *core* e padrões.
	- Diferentes tipos de sockets podem ter tipos de mensagens parecidas mas cujo conteúdo é diferente. 
		- Não se pode forçar o formato das mensagens.
 - **Minha solução:**	
	 - O campo do tipo de mensagens pode ser aproveitado, para os diferentes sockets criarem as suas próprias mensagens.
		 - Uma secção do espaço de tipos de mensagens é salvaguardada para possíveis funcionalidades **core** futuras.
		 - O restante espaço é reservado para tipos de mensagens associadas ao protocolo de comunicação de alto nível. Cada protocolo de comunicação pode redefinir este espaço como entender.
		 - Existindo a possibilidade, embora improvável, do esgotamento de cada um dos espaços (espaço core e espaço específico), pode ser sempre reservado criado um tipo de mensagem (no espaço com risco de esgotamento) que exige no seu payload que seja especificado o tipo de mensagem.  
	- Socket core preenche um objeto genérico com o tipo de mensagem e payload, e o socket de alto nível trata de processar a mensagem como entender.
	- Estas mensagens devem ser de controlo, e não serão afetadas pelo controlo de fluxo.
	- Para debug é necessário consultar duas tabelas (tabela *core* e tabela especifica do protocolo de alto nível).
	- Aproveita o campo do tipo de mensagem, logo não introduz overhead adicional.

<span style="color:orange">TODOs: 
<p>- Há forma de reaproveitar handle de certas mensagens?</p>
<p>- Reescrever o que for preciso tendo em conta as conclusões acima, incluindo a parte do estabelecimento do link deve ser descrita para incluir o processo simétrico.</p>
<p>- Ver ultimos 10 minutos da gravacao
</span>

