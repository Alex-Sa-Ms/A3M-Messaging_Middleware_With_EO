# Questões antes da reunião
- O professor na reunião de 6 maio falou que os sockets de alto nivel podem ter queues por destino e que se fosse atingido o limite de uma queue entao a operaçao de envio devia bloquear. No entanto, como nós queremos que sejam as threads clientes a executar a operação de envio, não faz sentido armazenar as mensagens em queues como se o envio destas estivesse a ser agendado para mais tarde. No entanto, acho que pode fazer sentido existir algo que controle qual deve ser o próximo destino como uma lista ligada circular.
	- **Resposta do Prof:** De facto não parece haver problemas em simplesmente entregar as mensagens ao Exon para envio. Não são precisas queues para envio. 
- Como expor os recibos de receção ao utilizador? 
	![[Reuniao 2024-05-06#Expor recibos de receção na API]]
	- Recibos (como discutido no email) passam a ser objectos que são definidos pelo cliente do Exon. 
	- Apenas se fornece um método **receive()** que dá prioridade a recibos e de seguida as mensagens. Se for fácil, pode-se criar uma proporção, por exemplo, após X recibos retornados seguidos, tenta-se retornar uma mensagem.
	- Recibos passam então a chamar-se de **Cookies**, já que podem conter qualquer coisa, podendo nem incluir um identificador da mensagem.

# Conclusões da reunião
## **Tratar de uma mensagem que chegou não pode bloquear.**
### Problema
- Utilizar o mecanismo de controlo de fluxo que utiliza os recibos de receção não salvaguarda o receptor contra "spam" dos transmissores, já que as mensagens serem recebidas não é equivalente a serem tratadas.
- Também não se pode dar *rely* no Exon para rejeitar mensagens em excesso porque apesar de ser uma solução que protege cada nodo de receber mensagens em excesso, isto não protege a rede de ser entupida com tráfego desnecessário.
### Solução
- Necessário criar mecanismo de controlo de fluxo baseado em entregas (em vez de ser baseado em recepções) e por nodo.
- Mecanismo passa a ser à base de créditos porque:
		- O receptor tem de informar o transmissor quando uma mensagem da sua autoria foi tratada.
	- Permite é mais versátil que e permite emular um mecanismo à base de janela.
	- Permite *batching*. Em vez de enviar uma mensagem de controlo por cada mensagem tratada, é possível definir o tamanho de um *batch*, X, e enviar uma mensagem de controlo a cada X mensagens tratadas desse transmissor. 
		- Exemplo: Um transmissor começa com 100 créditos, informados no *link handshake*. Admitindo que X tem valor 10, então, a cada 10 mensagens tratadas cuja fonte é o transmissor referido, o receptor envia uma mensagem de controlo a fornecer mais 10 créditos.
	- **Conclusão:** Criar um mecanismo parecido com o fornecido pelo AMQP.
- Através do estabelecimento de um limite para o número de links de um socket (L) e um número total de mensagens que podem ser enviadas por transmissor (M), então é possível fazer um cálculo aproximado do número de mensagens de utilizador (não confundir com mensagens de controlo / administrativas) que podem ficar armazenadas em incoming queues à espera de serem processadas: $$ Max. memoria\ em\ incoming\ queues  = L * M * max\_msg\_size $$
## Controlo de fluxo à base de créditos por nodo
- `SocketCore` implementa o comportamento básico para o controlo de fluxo, como negociar os créditos iniciais, permitir enviar mais créditos, etc.
- Para enviar uma mensagem, um `Socket` precisa de recorrer ao `SocketCore`. O `SocketCore` é então capaz de remover um crédito de envio (associado ao destino correto) por cada mensagem enviada.
- Os créditos devem ser alterados em função da entrega das mensagens para tratamento, e não em função da confirmação da chegada da mensagem ao destino. Como a entrega é feita pelo `Socket` e não pelo `SocketCore`, então o `Socket` passa a ser responsável por utilizar o `SocketCore` para dar créditos aos nodos fonte quando determinar que é necessário. 
	- O socket de alto nível (`Socket`) utiliza os métodos do `SocketCore` para gerir os créditos dos diferentes nodos associados.

## Fragmentação e agregação de mensagens (Futuro)
 - Fragmentação de mensagens com tamanho superior ao MTU deve ser feito pelo Exon.
 - Agregação de mensagens pequenas pode ser feito pelo Exon.

## Piggyback de mensagens
- O middleware pode permitir a criação de *multipart* messages.
- Útil para transferir diferentes mensagens num único payload.
- No entanto, como não existe um thread para gestão destes eventos, parece ser difícil encontrar um caso de uso para isto.
- Se mais tarde for passada a responsabilidade de envio para o middleware é possível agrupar mensagens de diferentes sockets no mesmo payload.

# Message structure
## Format
- **Fixed Header:**
	- **Version (2 bytes)**: Version of the middleware implementation.
	- **Middleware-level Protocol (1 byte)**: Identifies the middleware-level protocol. 
	- **Message Type (1 byte)**: Specifies the message type within the middleware-level protocol.
	- **Remaining Length (4 bytes)**: Remaining length of the message in bytes.
- **Extended Header:** 
	- Extension of the header which depends on the message type.
- **Payload:** 
	- **Data (variable length)**: Message content, treated as binary blob.
### Middleware-level protocol
The middleware-level protocol should not be confused with the messaging protocols that high-level sockets implement. It can be interpreted as the scope of the messages.
Currently, the middleware only contemplates a protocol. The contemplated middleware-level protocol is related to the sockets. However, in the future, new middleware-protocols may be implemented. One example could be a protocol related to nodes. Having a protocol identifier is useful for modularity, extensibility and efficiency[^3].
The message type is used to define the content of the extended header.
Defined message types:
- **Sockets (`0x01`)**: Messages related to socket operations.
- **Nodes (`0x02`)**: Messages related to node operations (for future use).
[^3] Efficiency in routing and message processing based on the header fields. 
## Socket middleware-level protocol
The socket middleware-level protocol is identified by **`0x01`**. It's a symmetrical protocol used by sockets to communicate with each other. It is symmetrical because it does not distinguish between clients and servers.
### Extended Header
The extender header of this protocol includes:
- **Source Tag (4 bytes)**: tag of the source socket.
- **Destination Tag (4 bytes)**: tag of the destination socket.
### Message Types
This protocol contemplates the following message types:

| **Type** | **Value** | **Description**           |
| -------- | --------- | ------------------------- |
| ERROR    | `0x01`    | Error message             |
| DATA     | `0x02`    | Data message              |
| LINK     | `0x03`    | Link request              |
| LINKACK  | `0x04`    | Link acknowledgment       |
| UNLINK   | `0x05`    | Link termination          |
| FLOW     | `0x06`    | Link flow control message |
### Errors
Any error related to a socket must be reported using a socket ERROR message. 
The payload of a socket ERROR message has the following format:
1. Error code (byte)
2. Textual representation of the error (string) \[*not mandatory*\]

The following table describes the errors that currently exist:

| Type                       | Code   | Description                                                                   |
| -------------------------- | ------ | ----------------------------------------------------------------------------- |
| **Socket not found**       | `0x01` | See below                                                                     |
| **Socket not linked**      | `0x02` | See below                                                                     |
| **Invalid message format** |        | Must be sent when a message is malformed. (Ignored because it seems useless.) |
|                            |        |                                                                               |
#### Socket Not Found 
A *Socket Not Found Error* message must be sent when a received message has a destination socket identifier that does not match the identifier of any socket registered on the receiving node.
The message must be formed as if the non existent socket was the one sending the error message, i.e., the "source tag" of the extended header must match the tag of the socket that does not exist. The "destination tag" must match the tag of the socket that intended to communicate with the non existent socket.
#### Socket Not Linked
A *Socket Not Linked Error* message must be sent when a message, that is not of type LINK, is received from a socket which is not linked with the destination socket. The received message should be discarded.

### Links
Having different sockets which talk using different messaging protocols is one of the goals of this messaging middleware. Having that said, a linking operation prevents sockets from being set up with sockets that do not talk the same messaging protocol. 

In the future, the linking operation may carry custom information[^1] that may contribute to the calculation of the decision on whether a link should be established or to serve only as parameters of the communication. 

[^1]This custom information may be related to the messaging protocol of the sockets or authorization/authentication purposes.
#### LINK message format

#### LINKACK message format
#### Establishing a link

**--------------------------(Is there anything that can be reused?)---------------------------**
To establish a link, a socket must send a `LINK` message to the socket it wants to establish a link with. A `LINK` message carries metadata about the sender. Currently, the only metadata that is mandatory is the *socket type* of the sender.
A socket that receives a `LINK` message must reply with a `LINKACK` message. If the socket type of the sender is compatible with the receiver, a `LINKACK` message must be sent containing a return code indicating success and the receiver's metadata. If the sender is not compatible, the receiver must reply with a `LINKACK` message containing a return code that indicates failure due to incompatibility between the socket types.
**---------------------------- // --------------------------------------------------------------**
As mentioned earlier, the main goal of establishing links is ensuring that only compatible sockets talk to each other. The compatibility test can only be performed if the sockets exchange metadata about each other. 

Currently, the only metadata required to achieve this purpose is the socket type. However, allowing the linking procedure to be extended with logic specific to the messaging protocol or for authorization/authentication purposes may be desirable for optimization. Instead of performing a handshake to establish a link and then performing another handshake related to the messaging protocol, the amount of messages exchanged may be reduced by carrying the metadata for the second handshake within the messages required to complete the link handshake.   

Let's assume that both sockets exchange LINK messages which purpose is to carry the metadata of the sender. Now, they both hold their own metadata and their counterpart's metadata. If we assume a symmetric linking procedure which only requires the counterpart's metadata, then no more messages need to be exchanged between the peers as they both will reach the same conclusion regarding the establishment of the link. However, while having in mind the extension of linking procedures, assuming such linking procedure to be symmetric is optimistic and naive. The sockets may have information that should not or cannot be shared[^2], making it impossible to achieve a symmetric linking procedure solely through the exchange of metadata. Hence, after receiving the counterpart's metadata and using it to reach a decision, each socket must share their decision regarding the link establishment through a LINKACK message. 

[^2] Let's consider an example where a socket is a server and demands authentication, and that the extension of the linking procedure includes the authentication process. The server cannot and must not share all its credentials with the client so that the client can generate the server's decision on its end.

When in possession of both decisions, the socket can calculate the final decision. If both decisions are positive, meaning that both sockets accepted the other socket as a counterpart, then the link is established. If at least one of the decisions is negative, then the link was not established.

Depending on which decision is negative, which socket issued the link establishment and the reason for the refusal, the information related to the other socket may be totally discarded. Let's consider that: (1) Socket A requests a link establishment to socket B; (2) Socket A accepts socket B for link establishment; (3) Socket B refuses socket A for link establishment due to having reached the limit of established links. In this example, A is the socket that wants to establish a link with B, and because we can infer from the reason for refusal that in the future B may accept A, A should issue a new request after a proper timeout. 




LINK messages carry the metadata of the sender. If both sockets exchange LINK messages, then both sockets have metadata about each other. If we assume that the linking procedure is symmetric, then no more messages need to be exchanged between the peers as they both will reach the same conclusion regarding the establishment of the link. However, if we assume that in the future, the linking procedure may be extended, the linking procedure may cease to be symmetric. If the linking procedure is not symmetric, i.e., if each socket may reach a different answer regarding the link establishment, then metadata exchange is not enough for a decision to be reached. It is also necessary that both sockets share their decision. If at least one of the sockets refuses the establishment of the link, then the link should not be established. The decision of each socket must be shared through a LINKACK message. To reduce the amount of traded messages to reach the final decision, a LINKACK message may care the sender's metadata if the metadata has not been sent yet.

In short, for a link to be established, both sockets must share their metadata and decision with the socket they want to form a link with. A decision can only be made after receiving the counterpart's metadata. A socket calculates the final decision after generating its own decision (from the counterpart's metadata) and receiving the counterpart's decision.

The order in which the counterpart's metadata and decision is received does not matter.


Essentially, there are 3 phases related to the establishment of a link:
1. Waiting counterpart metadata;
2. Waiting counterpart decision;
3. Calculation of the final decision.

**Most Common Scenario (only one socket requests the establishment):**

1. A ------- LINK with A's metadata ---------------> B

2. A <---- LINKACK with B's metadata ------------ B

3. A ------- LINKACK without A's metadata ----> B  _(A's metadata is not required as it was already sent in the LINK message)_

**Simultaneous Request Scenario (both sockets send a LINK message before receiving the other socket's LINK message):**
1. A <------- Exchange of LINK with metadata ---------------> B

2. A <------- Exchange of LINKACK without metadata ----> B



The flow is described in the following tables:
<span style="color:red"> Substituir flows por tabelas com ações de um único ator. Fazer flow para enviar LINK e fazer flow para receber LINK.</span>

The following tables describe the flow of sending a LINK message:

| Step | Actor    | Action                                                                         | Notes & References                                                                                                         |
| ---- | -------- | ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| BF-1 | Socket A | Sends LINK message to socket B containing A's metadata.                        |                                                                                                                            |
| BF-2 | Socket A | Waits for a message from socket B.                                             |                                                                                                                            |
| BF-3 | Socket A | Receives a LINKACK message from socket B containing B's decision and metadata. | AF-A (Receives a LINK message from socket B)                                                                               |
| BF-4 | Socket A | Generates its own decision using B's metadata.                                 |                                                                                                                            |
| BF-5 | Socket A | Sends LINKACK message to B containing A's decision.                            | A's metadata is not sent since B has already received and used it to calculate its own decision.                           |
| BF-6 | Socket A | Calculates final decision using its own decision and B's decision.             | The final decision is "link accepted" if both sockets accepted the establishment of the link. Or "link refused" otherwise. |
| BF-7 | Socket A | Verifies that the final decision is "link accepted".                           | EF-A (Link refused)                                                                                                        |
| BF-8 | Socket A | Registers Socket B as a linked socket.                                         |                                                                                                                            |

**AF-A (Receives a LINK message from socket B):**

| Step   | Actor    | Action                                                         | Notes & References                                                                                                                                                                                                                            |
| ------ | -------- | -------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| AF-A-1 | Socket A | Receives a LINK message from socket B containing B's metadata. |                                                                                                                                                                                                                                               |
| AF-A-2 | Socket A | Generates its own decision using B's metadata.                 |                                                                                                                                                                                                                                               |
| AF-A-3 | Socket A | Sends LINKACK message to B containing A's decision.            |                                                                                                                                                                                                                                               |
| AF-A-4 | Socket A | Waits for a LINKACK or DATA message from B.                    | DATA messages can only be sent if the final decision is "link accepted". As the final decision involves both sockets decisions, receiving a DATA message before a LINKACK message means that the counterpart socket has established the link. |
| AF-A-5 | Socket A | Receives a LINKACK message from B containing B's decision.     | AF-B (Receives a DATA message from socket B)                                                                                                                                                                                                  |
| AF-A-6 | Socket A | Returns to BF-6.                                               |                                                                                                                                                                                                                                               |

**AF-B (Receives a DATA message from socket B):**

| Step   | Actor    | Action                                                                                        | Notes & References |
| ------ | -------- | --------------------------------------------------------------------------------------------- | ------------------ |
| AF-B-1 | Socket A | Receives a DATA message from B.                                                               |                    |
| AF-B-2 | Socket A | Returns to BF-7.                                                                              |                    |
| AF-B-3 | Socket A | Receives a LINKACK message from B containing B's decision.                                    |                    |
| AF-B-4 | Socket A | Ignores the LINKACK message as the DATA message was used to infer a positive decision from B. |                    |





<span style="color:red"> Fazer flow para receber LINK. Reler tudo (tanto as tabelas como o resto relacionado com os links).</span>



-----
----------
------------


| Step  | Actor    | Action                                                                                            | Notes & References                                                                                                         |
| ----- | -------- | ------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| BF-1  | Socket A | Sends LINK message to socket B.                                                                   |                                                                                                                            |
| BF-2  | Socket B | Receives a LINK message from A.                                                                   |                                                                                                                            |
| BF-3  | Socket B | Verifies if a LINK message has not been sent to A.                                                | AF-A (LINK message has been sent to A)                                                                                     |
| BF-4  | Socket B | Generates its own decision using A's metadata.                                                    |                                                                                                                            |
| BF-5  | Socket B | Sends LINKACK message to A containing its B's decision and metadata.                              |                                                                                                                            |
| BF-6  | Socket A | Receives LINKACK message from B.                                                                  |                                                                                                                            |
| BF-7  | Socket A | Generates its own decision using B's metadata.                                                    |                                                                                                                            |
| BF-8  | Socket A | Sends LINKACK message to B containing A's decision.                                               | A's metadata is not sent since B has already received and used it to calculate its own decision.                           |
| BF-9  | Socket A | Calculates final decision using its own decision and B's decision present in the LINKACK message. | The final decision is "link accepted" if both sockets accepted the establishment of the link. Or "link refused" otherwise. |
| BF-10 | Socket A | Verifies that the final decision is "link accepted".                                              | EF-A (Link refused)                                                                                                        |
| BF-11 | Socket A | Registers Socket B as a linked socket.                                                            |                                                                                                                            |
| BF-12 | Socket B | Receives LINKACK message from A.                                                                  |                                                                                                                            |
| BF-13 | Socket B | Calculates final decision using its own decision and A's decision present in the LINKACK message. |                                                                                                                            |
| BF-14 | Socket B | Verifies that the final decision is "link accepted".                                              |                                                                                                                            |
| BF-15 | Socket B | Registers Socket A as a linked socket.                                                            |                                                                                                                            |


**AF-A (LINK message has been sent to A):**

| Step   | Actor    | Action                                                                                            | Notes & References                                     |
| ------ | -------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| AF-A-1 | Socket B | Generates its own decision using A's metadata.                                                    |                                                        |
| AF-A-2 | Socket B | Sends LINKACK message to A containing B's decision.                                               |                                                        |
| AF-A-3 | Socket A | Receives LINK message from B.                                                                     | AF-A-3.1 (LINKACK message arrived before LINK message) |
| AF-A-4 | Socket A | Generates its own decision using B's metadata.                                                    |                                                        |
| AF-A-5 | Socket A | Sends LINKACK message to B containing A's decision.                                               |                                                        |
| AF-A-6 | Socket A | Receives LINKACK message from B.                                                                  |                                                        |
| AF-A-7 | Socket A | Calculates final decision using its own decision and B's decision present in the LINKACK message. |                                                        |
| AF-A-8 | Socket A | Verifies that the final decision is "link accepted".                                              | EF-A (Link refused)                                    |
| AF-A-9 | Socket A |                                                                                                   |                                                        |


**EF-A (Link refused):**

| Step | Actor | Action | Notes & References |
| ---- | ----- | ------ | ------------------ |


After sending a LINK message, the socket enters the "Waiting counterpart metadata" phase where it awaits for the metadata of the other socket.



Progressing to the "Waiting counterpart decision" can happen after receiving a LINK or a LINKACK message. When receivign



After receiving metadata through a LINKACK message, the socket receives both the metadata required to create its own decision and the decision of the other socket. Since it has both decisions in its possession, it can generate the final decision. The link is established if both sockets agree on establishing the link.

A socket may also progress from the "Waiting counterpart metadata" through the reception of a LINK message. In this case, using the received metadata, a decision must be reached and sent to the counterpart socket. Then, it should wait for the counterpart decision to be sent, to reach the final decision

<span style="color:yellow">Receipts may be useful to prevent queuing at the destination socket. Even if a socket has reached the final decision, the counterpart may not have reached the decision because its waiting for a LINKACK message to arrive with the counterpart decision. In this situation, one socket is ready to send messages, but doing so before the other socket receives the LINKACK messages may result in the arrival of these messages before the LINKACK message. Since a socket can only send DATA messages to another socket if the linking operation is successful, there is no reason for the messages to be discarded, hence, they must be queued until the LINKACK message arrives. To prevent unnecessary queuing of messages, waiting for a receipt that indicates the arrival of the message at the destination may be a solution. <b style="color:limegreen">Another solution is just considering the link establishment a success when a DATA message arrives, since, as mentioned earlier, DATA messages can only flow when the link establishment is successful.</b> However, the receipts may be a useful feature nonetheless.</span> 

#### Terminating a link
#### Link states
#### Link Errors
#### <span style="color:red">Notes</span>
- The client send operation needs to block until a destination is available.

### Flow control
The socket flow control is performed per link.


<span style="color:red">Ver processo de connect do MQTT para fazer igual para o estabelecimento de links</span>

<span style="color:red">Ver processo de flow do AMQP para fazer igual para o controlo de fluxo</span>

## Tipos de payloads

<span style="color:red">Criar tabela igual à da figura 2.10 (Frame Dispatch Table) do AMQP mas com "Nodo", "Socket Core" e "Socket".</span>
## Otimizações futuras
### Otimização do espaço utilizado por tags
- Para otimizar o espaço ocupado por tags nas mensagens relacionadas com sockets, no estabelecimento de um link, cada nodo envia uma identificação mais curta do seu socket. 
	- Por exemplo, um inteiro.  
- A tag apenas é necessária para encontrar o socket no nodo destino, após ser encontrado o socket pode-se utilizar a identificação curta fornecida pelo nodo destino.
- É necessário ter cuidado ao fazer *reclaim* dos identificadores para novos sockets. Se é que se pode fazer.
## Notas
- Identificadores dos nodos é responsabilidade do Exon, não é da responsabilidade do Middleware referir estes identificadores. 
- 