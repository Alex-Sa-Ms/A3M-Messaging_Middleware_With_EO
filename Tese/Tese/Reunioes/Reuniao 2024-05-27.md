# Questões antes da reunião
- O professor na reunião de 6 maio falou que os sockets de alto nivel podem ter queues por destino e que se fosse atingido o limite de uma queue entao a operaçao de envio devia bloquear. No entanto, como nós queremos que sejam as threads clientes a executar a operação de envio, não faz sentido armazenar as mensagens em queues como se o envio destas estivesse a ser agendado para mais tarde. No entanto, acho que pode fazer sentido existir algo que controle qual deve ser o próximo destino como uma lista ligada circular.
	- **Resposta do Prof:** De facto não parece haver problemas em simplesmente entregar as mensagens ao Exon para envio. Não são precisas queues para envio. 
- Como expor os recibos de receção ao utilizador? 
	![[Reuniao 2024-05-06#Expor recibos de receção na API]]
	- Recibos (como discutido no email) passam a ser objectos que são definidos pelo cliente do Exon. 
	- Apenas se fornece um método **receive()** que dá prioridade a recibos e de seguida as mensagens. Se for fácil, pode-se criar uma proporção, por exemplo, após X recibos retornados seguidos, tenta-se retornar uma mensagem.
	- Recibos passam então a chamar-se de **Cookies**, já que podem conter qualquer coisa, podendo nem incluir um identificador da mensagem.

# Conclusões da reunião
## **Tratar de uma mensagem que chegou não pode bloquear.**
### Problema
- Utilizar o mecanismo de controlo de fluxo que utiliza os recibos de receção não salvaguarda o receptor contra "spam" dos transmissores, já que as mensagens serem recebidas não é equivalente a serem tratadas.
- Também não se pode dar *rely* no Exon para rejeitar mensagens em excesso porque apesar de ser uma solução que protege cada nodo de receber mensagens em excesso, isto não protege a rede de ser entupida com tráfego desnecessário.
### Solução
- Necessário criar mecanismo de controlo de fluxo baseado em entregas (em vez de ser baseado em recepções) e por nodo.
- Mecanismo passa a ser à base de créditos porque:
		- O receptor tem de informar o transmissor quando uma mensagem da sua autoria foi tratada.
	- Permite é mais versátil que e permite emular um mecanismo à base de janela.
	- Permite *batching*. Em vez de enviar uma mensagem de controlo por cada mensagem tratada, é possível definir o tamanho de um *batch*, X, e enviar uma mensagem de controlo a cada X mensagens tratadas desse transmissor. 
		- Exemplo: Um transmissor começa com 100 créditos, informados no *link handshake*. Admitindo que X tem valor 10, então, a cada 10 mensagens tratadas cuja fonte é o transmissor referido, o receptor envia uma mensagem de controlo a fornecer mais 10 créditos.
	- **Conclusão:** Criar um mecanismo parecido com o fornecido pelo AMQP.
- Através do estabelecimento de um limite para o número de links de um socket (L) e um número total de mensagens que podem ser enviadas por transmissor (M), então é possível fazer um cálculo aproximado do número de mensagens de utilizador (não confundir com mensagens de controlo / administrativas) que podem ficar armazenadas em incoming queues à espera de serem processadas: $$ Max. memoria\ em\ incoming\ queues  = L * M * max\_msg\_size $$
## Controlo de fluxo à base de créditos por nodo
- `SocketCore` implementa o comportamento básico para o controlo de fluxo, como negociar os créditos iniciais, permitir enviar mais créditos, etc.
- Para enviar uma mensagem, um `Socket` precisa de recorrer ao `SocketCore`. O `SocketCore` é então capaz de remover um crédito de envio (associado ao destino correto) por cada mensagem enviada.
- Os créditos devem ser alterados em função da entrega das mensagens para tratamento, e não em função da confirmação da chegada da mensagem ao destino. Como a entrega é feita pelo `Socket` e não pelo `SocketCore`, então o `Socket` passa a ser responsável por utilizar o `SocketCore` para dar créditos aos nodos fonte quando determinar que é necessário. 
	- O socket de alto nível (`Socket`) utiliza os métodos do `SocketCore` para gerir os créditos dos diferentes nodos associados.

## Fragmentação e agregação de mensagens (Futuro)
 - Fragmentação de mensagens com tamanho superior ao MTU deve ser feito pelo Exon.
 - Agregação de mensagens pequenas pode ser feito pelo Exon.

## Piggyback de mensagens
- O middleware pode permitir a criação de *multipart* messages.
- Útil para transferir diferentes mensagens num único payload.
- No entanto, como não existe um thread para gestão destes eventos, parece ser difícil encontrar um caso de uso para isto.
- Se mais tarde for passada a responsabilidade de envio para o middleware é possível agrupar mensagens de diferentes sockets no mesmo payload.

# Message format
<b style="color:red">Check MQTT and AMQP specifications to organize everything.</b>
## Message structure
- **Fixed Header:**
	- **Version (2 bytes)**: Version of the middleware implementation.
	- **Middleware-level Protocol (1 byte)**: Identifies the middleware-level protocol. 
	- **Message Type (1 byte)**: Specifies the message type within the middleware-level protocol.
	- **Remaining Length (4 bytes)**: Remaining length of the message in bytes.
	- **Source Node Identifier (Omitted**[^1]**)**: identifier of the node that sent the message.
	- **Destination Node Identifier (Omitted**[^1]**)**: identifier of the node that should receive the message.
- **Extended Header:** 
	- Extension of the header which depends on the middleware-level protocol.
- **Payload:** 
	- **Data (variable length)**: Message content, treated as binary blob.

[^1] Omitted because the Exon library messages already carry such identifiers.
### Middleware-level protocol
The middleware-level protocol should not be confused with the messaging protocols that high-level sockets implement. It can be interpreted as the scope of the messages.
Currently, the middleware only contemplates a protocol. The contemplated middleware-level protocol is related to the sockets. However, in the future, new middleware-protocols may be implemented. One example could be a protocol related to nodes. Having a protocol identifier is useful for modularity, extensibility and efficiency[^3].
The message type is used to define the content of the extended header.
Defined message types:
- **Sockets (`0x01`)**: Messages related to socket operations.
- **Nodes (`0x02`)**: Messages related to node operations (for future use).
[^3] Efficiency in routing and message processing based on the header fields. 
# Socket middleware-level protocol

## Socket messages format
The socket middleware-level protocol is identified by **`0x01`**. It's a symmetrical protocol used by sockets to communicate with each other. It is symmetrical because peers do not assume different roles, like client and server.
### Extended Header
The extender header of this protocol includes:
- **Source Tag (4 bytes)**: tag of the socket that sent the message.
- **Destination Tag (4 bytes)**: tag of the socket that should receive the message.
### Message Types
This protocol contemplates the following message types:

| **Type** | **Value** | **Description**           |
| -------- | --------- | ------------------------- |
| ERROR    | `0x01`    | Error message             |
| LINK     | `0x02`    | Link request              |
| LINKACK  | `0x03`    | Link acknowledgment       |
| UNLINK   | `0x04`    | Link termination          |
| FLOW     | `0x05`    | Link flow control message |
| CONTROL  | `0x06`    | Control message           |
| DATA     | `0x07`    | Data message              |

### Payload
The payload of a socket message depends on the message type.
## Errors
This section presents errors related to the socket middleware-protocol. 

The possible errors are shown in the table below, along with their corresponding code and whether the error is reported through an ERROR message.

| Type                       | Code   | Reported |
| -------------------------- | ------ | -------- |
| **Socket not found**       | `0x01` | True     |
| **Socket not linked**      | `0x02` | True     |
| **Invalid message format** | `0x03` | False    |
#### Socket Not Found 
A *Socket Not Found Error* must be reported when a received message has a destination tag that does not match any socket registered on the receiving node.
The message must be formed as if the non existent socket was the one sending the error message, i.e., the "source tag" of the extended header must match the tag of the socket that does not exist. The "destination tag" must match the tag of the socket that intended to communicate with the non existent socket.
#### Socket Not Linked
A *Socket Not Linked Error* must be sent when a non-link-related message is received from a socket which is not linked with the destination socket. The received message should be discarded.
#### Invalid Message Format
A *Socket Invalid Message Format Error* happens when a received message does not follow a valid format. The message should be discarded as the socket cannot process the message. 
This error should be logged for debug purposes. Reporting the error to the message sender does not accomplish anything as sockets do not store sent messages. Due to Exon's delivery guarantee, sockets do not need to store sent messages as Exon ensures that messages arrive at the destination. 
## Links
One of the goals of this messaging middleware is to facilitate the creation and use of various messaging protocols. To prevent sockets from trying to communicate with those using a different messaging protocol, a link establishment process is necessary. For two sockets to communicate with each other, they must engage in a link handshake, whose primary purpose is to verify their compatibility.
#### Establishing a link

For a link to be established, both sockets must agree to link with each other. A socket establishes the link on its end when it has made its own decision, received the counterpart socket's decision, and both decisions indicate acceptance. To make a decision, a socket requires the metadata of the counterpart socket. Therefore, both sockets must share their metadata, formulate their decisions and exchange these decisions.

To accomplish the above, two types of messages are employed: `LINK` and `LINKACK`. The `LINK` message initiates the linking process[^1] and carries the socket's metadata. The `LINKACK` message is used to send the socket's decision, but it can also include the socket's metadata if it has not been sent yet.

[^1] "Linking process" is an alias of "Link establishment process".

Having that said, the main possible linking flows are the following:
- **Scenario 1 (Only one socket initiates the link establishment process):**
	1. Socket A sends `LINK` message to socket B;
	2. Socket B formulates a decision using the received metadata;
	3. Socket B sends a `LINKACK` message containing its decision and metadata;
	4. Socket A uses the received metadata to formulate its decision and sends it to socket B in a `LINKACK` message[^a];
	5. Both sockets analyze the decisions. If both decisions are positive, they establish the link by registering each other as linked sockets.
- **Scenario 2 (Both sockets initiate the link establishment process simultaneously):**
	1. Socket A and Socket B both send `LINK` messages to each other;
	2. Each socket uses the other's metadata to its decision;
	3. Both sockets share their decision;
	4. Both sockets analyze the decisions. If both decisions are positive, they establish the link by registering each other as linked sockets.
- The remaining possible flows can be verified through the examination of the state machine diagram presented further ahead. 

[^a] Socket A's metadata is not included in the `LINKACK` messages as it was already sent previously in the `LINK` message.

The main goal of establishing links is to ensure compatibility, which can only be determined through the exchange of metadata. Currently, the only required metadata is the socket type. However, extending the linking process to include custom logic, such as messaging protocol logic or authorization/authentication procedures, might be beneficial. This could reduce the number of messages exchanged by embedding custom metadata within the link handshake messages, instead of performing additional handshakes after establishing the link.

In an ideal linking procedure, both sockets could reach the same conclusion regarding the link establishment solely through the exchange of their metadata (sent in `LINK` messages). As the only required metadata, at the moment, is the socket type, such procedure would be possible. However, when considering custom extensions of the linking procedure, assuming that all these extensions can be symmetric[^1] is optimistic and naive. Sockets may have information that should not or cannot be shared[^2], making it impossible for sockets to reach the same conclusion solely through the exchange of metadata. Therefore, after receiving the counterpart's metadata and formulating a decision, each socket must share its decision regarding the link establishment through a `LINKACK` message.

[^1] We can view a symmetric linking procedure as a function that receives the metadata of both sockets and produces the same result. 

[^2] Let's consider an example where a socket is a server and demands authentication, and that the extension of the linking procedure includes the authentication process. The server cannot and must not share all its credentials with the client so that the client can generate the server's decision on its end.

Since the most common scenario involves one socket initiating the link establishment process, the `LINKACK` messages may include metadata along with the socket's decision. This reduces the number of messages needed to reach the final decision.

When a socket has both decisions, it can calculate the final decision. If both decisions are positive, the link is established. If at least one decision is negative, the link is not established.

Depending on which decision is negative, which socket initiated the link establishment, and the reason for the refusal, the information related to the other socket may be discarded. A socket that initiates a link establishment will only discard all information related to the other socket if the reason for refusal is incompatibility[^3]. If the reason differs from incompatibility (e.g., refusal due to reaching the limit of established links), the requester may issue a new link establishment request after a proper timeout[^4]. A socket receiving a link establishment request is not obligated to retain the information of the requester if the refusal reason differs from incompatibility, as it was not its intention to establish the link.

[^3] Incompatibility can only be used as a refusal reason if the rejection factor is a static parameter that will not change during the socket's life, such as the socket type.
[^4] Establishing random timeouts is ideal to avoid link establishment request storms.

In this linking process, one socket (A) always establishes the link first, while the other socket (B) awaits A's decision. Once A has established the link, it can start sending messages to B. However, due to the transport protocol's lack of order guarantees, a message from A that is unrelated to the linking process may reach B before A's `LINKACK` message. Since sockets are prohibited from exchanging messages with a non-linked socket, if B receives a non-link-related message while still awaiting A's decision, B can interpret this message as an implicit positive decision from A. B can then proceed to establish the link and process the received message.

The following state machine diagram is a visual representation of the different states and transitions that a socket may undergo during a link establishment process.
![[Link establishment State Machine.png]]


#### Cancelling a link establishment process
Sending an `UNLINK` message during a link establishment process, results in the deletion of all information related to the `UNLINK` message sender. 
##### Potential problem
There is no ordering guarantee, so it is possible that an `UNLINK` message arrives before sent `LINK`/`LINKACK` messages. Arriving before a `LINK` message means that the `UNLINK` message won't have any effect. Arriving before a `LINKACK` should not result in any problem as long as another linking process is not started which may result in the delivery of a response that should not be delivered.

**Solution:** link related messages must carry a unique identifier that identifies the linking process. That way, messages not related to the current linking process may be ignored.

**Solution 2:** Not allowing an operation B that cancels an operation A already in progress to be executed until operation A is finished. 

#### Terminating a link

#### <span style="color:red">Notes</span>
- The client send operation needs to block until a destination is available.

## Flow control
The socket flow control is performed per link.

<span style="color:red">Ver processo de flow do AMQP para fazer igual para o controlo de fluxo</span>

### Control and data messages 
#### Pros
Distinguishing between control and data messages allows control messages to bypass the flow control mechanism, ensuring that critical operational commands are not delayed and thus maintaining system responsiveness. This also simplifies the design of the flow control mechanism, enabling automatic updates of flow control windows.
#### Potential Concerns
Since control messages are not managed by the flow control mechanism, it's crucial to avoid overusing them in messaging protocols, as they could overwhelm destinations and cause network congestion.
Security is not a primary objective, however, it should not be overlooked. A potential security issue is the misuse of control messages by malicious actors to bypass flow control and disrupt the system by flooding it with control messages.
## Socket messages
<span style="color:red">Criar tabela igual à da figura 2.10 (Frame Dispatch Table) do AMQP mas com "Nodo", "Socket Core" e "Socket".</span>
### LINK message

### LINKACK message

### CONTROL message

### DATA message


## Otimizações futuras
### Otimização do espaço utilizado por tags
- Para otimizar o espaço ocupado por tags nas mensagens relacionadas com sockets, no estabelecimento de um link, cada nodo envia uma identificação mais curta do seu socket. 
	- Por exemplo, um inteiro.  
- A tag apenas é necessária para encontrar o socket no nodo destino, após ser encontrado o socket pode-se utilizar a identificação curta fornecida pelo nodo destino.
- É necessário ter cuidado ao fazer *reclaim* dos identificadores para novos sockets. Se é que se pode fazer.