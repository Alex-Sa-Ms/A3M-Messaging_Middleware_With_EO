# Questões antes da reunião
- O professor na reunião de 6 maio falou que os sockets de alto nivel podem ter queues por destino e que se fosse atingido o limite de uma queue entao a operaçao de envio devia bloquear. No entanto, como nós queremos que sejam as threads clientes a executar a operação de envio, não faz sentido armazenar as mensagens em queues como se o envio destas estivesse a ser agendado para mais tarde. No entanto, acho que pode fazer sentido existir algo que controle qual deve ser o próximo destino como uma lista ligada circular.
	- **Resposta do Prof:** De facto não parece haver problemas em simplesmente entregar as mensagens ao Exon para envio. Não são precisas queues para envio. 
- Como expor os recibos de receção ao utilizador? 
	![[Reuniao 2024-05-06#Expor recibos de receção na API]]
	- Recibos (como discutido no email) passam a ser objectos que são definidos pelo cliente do Exon. 
	- Apenas se fornece um método **receive()** que dá prioridade a recibos e de seguida as mensagens. Se for fácil, pode-se criar uma proporção, por exemplo, após X recibos retornados seguidos, tenta-se retornar uma mensagem.
	- Recibos passam então a chamar-se de **Cookies**, já que podem conter qualquer coisa, podendo nem incluir um identificador da mensagem.

# Conclusões da reunião
## **Tratar de uma mensagem que chegou não pode bloquear.**
### Problema
- Utilizar o mecanismo de controlo de fluxo que utiliza os recibos de receção não salvaguarda o receptor contra "spam" dos transmissores, já que as mensagens serem recebidas não é equivalente a serem tratadas.
- Também não se pode dar *rely* no Exon para rejeitar mensagens em excesso porque apesar de ser uma solução que protege cada nodo de receber mensagens em excesso, isto não protege a rede de ser entupida com tráfego desnecessário.
### Solução
- Necessário criar mecanismo de controlo de fluxo baseado em entregas (em vez de ser baseado em recepções) e por nodo.
- Mecanismo passa a ser à base de créditos porque:
		- O receptor tem de informar o transmissor quando uma mensagem da sua autoria foi tratada.
	- Permite é mais versátil que e permite emular um mecanismo à base de janela.
	- Permite *batching*. Em vez de enviar uma mensagem de controlo por cada mensagem tratada, é possível definir o tamanho de um *batch*, X, e enviar uma mensagem de controlo a cada X mensagens tratadas desse transmissor. 
		- Exemplo: Um transmissor começa com 100 créditos, informados no *link handshake*. Admitindo que X tem valor 10, então, a cada 10 mensagens tratadas cuja fonte é o transmissor referido, o receptor envia uma mensagem de controlo a fornecer mais 10 créditos.
	- **Conclusão:** Criar um mecanismo parecido com o fornecido pelo AMQP.
- Através do estabelecimento de um limite para o número de links de um socket (L) e um número total de mensagens que podem ser enviadas por transmissor (M), então é possível fazer um cálculo aproximado do número de mensagens de utilizador (não confundir com mensagens de controlo / administrativas) que podem ficar armazenadas em incoming queues à espera de serem processadas: $$ Max. memoria\ em\ incoming\ queues  = L * M * max\_msg\_size $$
## Controlo de fluxo à base de créditos por nodo
- `SocketCore` implementa o comportamento básico para o controlo de fluxo, como negociar os créditos iniciais, permitir enviar mais créditos, etc.
- Para enviar uma mensagem, um `Socket` precisa de recorrer ao `SocketCore`. O `SocketCore` é então capaz de remover um crédito de envio (associado ao destino correto) por cada mensagem enviada.
- Os créditos devem ser alterados em função da entrega das mensagens para tratamento, e não em função da confirmação da chegada da mensagem ao destino. Como a entrega é feita pelo `Socket` e não pelo `SocketCore`, então o `Socket` passa a ser responsável por utilizar o `SocketCore` para dar créditos aos nodos fonte quando determinar que é necessário. 
	- O socket de alto nível (`Socket`) utiliza os métodos do `SocketCore` para gerir os créditos dos diferentes nodos associados.

## Fragmentação e agregação de mensagens (Futuro)
 - Fragmentação de mensagens com tamanho superior ao MTU deve ser feito pelo Exon.
 - Agregação de mensagens pequenas pode ser feito pelo Exon.

## Piggyback de mensagens
- O middleware pode permitir a criação de *multipart* messages.
- Útil para transferir diferentes mensagens num único payload.
- No entanto, como não existe um thread para gestão destes eventos, parece ser difícil encontrar um caso de uso para isto.
- Se mais tarde for passada a responsabilidade de envio para o middleware é possível agrupar mensagens de diferentes sockets no mesmo payload.